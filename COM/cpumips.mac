|***********************************************************************|
|									|
|									|
|	8080/Z-80 Simulator for MIPS (Big-Endian)			|
|									|
|	Version 3.2 12/15/2008 JEC					|
|		Ported PPC assembly to MIPS assembly.			|
|									|
|	This program has been written for speed wherever possible,	|
|	as such tends to be large because of the separate subroutine	|
|	for each and every opcode of the target processor.  Note that	|
|	the 'speedy' structure was optimal for a 680x0, whereas this	|
|	is more of a port of that structure rather than something that	|
|	was designed to be optimal for the MIPS.  This version uses	|
|	large lookup tables for the target AF registers, which has	|
|	cache implications.  No accounting for cache or pipeline	|
|	behavior has been made.  Further optimization is no doubt	|
|	possible.							|
|									|
|	It is not a perfect simulation, as some flag handling		|
|	is not quite right, but it is enough to run the programs	|
|	I wrote it for: DDT, LU, MAC, and the Morrow FORMATMW.		|
|	Programs like WordStar 3.0 and MBASIC also work fine.		|
|									|
|***********************************************************************|

|***********************************************************************|
|									|
|	This file contains the target processor (8080/Z-80) simulation	|
|	routines.							|
|									|
|***********************************************************************|

#include "mipsmacros.h"	/* Get NEXT code & declarations. */

	.globl service,illegal,stepper
#ifdef Z80
	.globl badop,CBoptab,DDoptab,EDoptab,FDoptab,DDCBopt
#endif

 	.text
|***********************************************************************|
|									|
|	Opcode simulation subroutines.					|
|									|
|***********************************************************************|

	.set noat	| Allow use of $1 in this code for scratch.

nop00:	next					| 00 NOP

lxib:	lbu $3,0(pseudopc)			| 01 LXI B,nnnn
	sb $3,regc(regs)
	lbu $3,1(pseudopc)
	addiu pseudopc,pseudopc,2
	sb $3,regd(regs)
	next

staxb:	lhu $3,regb(regs)			| 02 STAX B
	addu $3,$3,targbase
	sb rega,0($3)
	next

inxb:	lhu $3,regb(regs)			| 03 INX B
	addu $3,$3,regcon01
	sh $3,regb(regs)
	next

inrb:	lbu $3,regb(regs)			| 04 INR B
	inrflag($3)
	sb $3,regb(regs)
	next

dcrb:	lbu $3,regb(regs)			| 05 DCR B
	dcrflag($3)
	sb $3,regb(regs)
	next

mvib:	lbu $3,0(pseudopc)			| 06 MVI B,nn
	addu pseudopc,pseudopc,regcon01
	sb $3,regb(regs)
	next

rlca:	RLCR(rega)				| 07 RLC
#ifdef Z80
	andi regf,regf,0xE5
#endif
	next

exaf:
#ifdef Z80
	move $3,rega	 			| 08 EXAF (Z-80)
	lbu rega,rega2(regs)
	sb $3,rega2(regs)
	move $3,regf
	lbu regf,regf2(regs)
	sb $3,regf2(regs)
	next
#else
	j badop					| 08 Illegal for 8080
	nop
#endif

dadb:	lhu $2,regb(regs)			| 09 DAD B
	lhu $3,regh(regs)
	addu $3,$3,$2
	sh $3,regh(regs)
	carryf($3)
	next


ldaxb:	lhu $3,regb(regs)			| 0A LDAX B
	addu $3,$3,targbase
	lbu rega,0($3)
	next

dcxb:	lhu $3,regb(regs)			| 0B DCX B
	subu $3,$3,regcon01
	sh $3,regb(regs)
	next

inrc:	lbu $3,regc(regs)			| 0C INR C
	inrflag($3)
	sb $3,regc(regs)
	next

dcrc:
#ifdef RUNOPTS
	lbu $3,1(pseudopc)
	li $2,0x20
	bne $3,$2,dcrc1
	lbu $3,2(pseudopc)
	li $2,0xFD
	bne $3,$2,dcrc1
	lbu $3,regc(regs)
	beq $3,$0,dcrc1
	sb regcon01,regc(regs)
dcrc1:
#endif
	lbu $3,regc(regs)			| 0D DCR C
	dcrflag($3)
	sb $3,regc(regs)
	next

mvic:	lbu $3,0(pseudopc)			| 0E MVI C,nn
	addu pseudopc,pseudopc,regcon01
	sb $3,regc(regs)
	next

rrca:	RRCR(rega)				| 0F RRC
#ifdef Z80
	andi regf,regf,0xE5
#endif
	next

djnz:
#ifdef Z80
	lb $2,0(pseudopc)			| 10 DJNZ dd (Z-80)
	addu pseudopc,pseudopc,regcon01
	lbu $3,regb(regs)
	subu $3,$3,regcon01
	sb $3,regb(regs)
	beq $3,$0,djnzx
	addu pseudopc,pseudopc,$2
djnzx:	next
#else
	j badop					| 10 Illegal for 8080
	nop
#endif

lxid:	lbu $3,0(pseudopc)			| 11 LXI D,nnnn
	sb $3,rege(regs)
	lbu $3,1(pseudopc)
	addiu pseudopc,pseudopc,2
	sb $3,regd(regs)
	next

staxd:	lhu $3,regd(regs)			| 12 STAX D
	addu $3,$3,targbase
	sb rega,0($3)
	next

inxd:	lhu $3,regd(regs)			| 13 INX D
	addu $3,$3,regcon01
	sh $3,regd(regs)
	next

inrd:	lbu $3,regd(regs)			| 14 INR D
	inrflag($3)
	sb $3,regd(regs)
	next

dcrd:	lbu $3,regd(regs)			| 15 DCR D
	dcrflag($3)
	sb $3,regd(regs)
	next

mvid:	lbu $3,0(pseudopc)			| 16 MVI D,nn
	addu pseudopc,pseudopc,regcon01
	sb $3,regd(regs)
	next

ral:	RALR(rega)				| 17 RAL
#ifdef Z80
	andi regf,regf,0xE5
#endif
	next

jr:
#ifdef Z80
	lb $2,0(pseudopc)			| 18 JR dd (Z-80)
	addu pseudopc,pseudopc,regcon01
	addu pseudopc,pseudopc,$2
	next
#else
	j badop					| 18 Illegal for 8080
	nop
#endif

dadd:	lhu $2,regd(regs)			| 19 DAD D
	lhu $3,regh(regs)
	addu $3,$3,$2
	sh $3,regh(regs)
	carryf($3)
	next

ldaxd:	lhu $3,regd(regs)			| 1A LDAX D
	addu $3,$3,targbase
	lbu rega,0($3)
	next

dcxd:	lhu $3,regd(regs)			| 1B DCX D
	subu $3,$3,regcon01
	sh $3,regd(regs)
	next

inre:	lbu $3,rege(regs)			| 1C INR E
	inrflag($3)
	sb $3,rege(regs)
	next

dcre:	lbu $3,rege(regs)			| 1D DCR E
	dcrflag($3)
	sb $3,rege(regs)
	next

mvie:	lbu $3,0(pseudopc)			| 1E MVI E,nn
	addu pseudopc,pseudopc,regcon01
	sb $3,rege(regs)
	next

rar:	RARR(rega)				| 1F RAR
#ifdef Z80
	andi regf,regf,0xE5
#endif
	next

jrnz:
#ifdef Z80
	lb $2,0(pseudopc)			| 20 JRNZ dd (Z-80)
	addu pseudopc,pseudopc,regcon01
	andi $3,regf,0x40
	bne $3,$0,lxihx
	addu pseudopc,pseudopc,$2
	next
#else
	j badop					| 20 Illegal for 8080
	nop
#endif

lxih:	lbu $3,0(pseudopc)			| 21 LXI H,nnnn
	sb $3,regl(regs)
	lbu $3,1(pseudopc)
	addiu pseudopc,pseudopc,2
	sb $3,regh(regs)
lxihx:	next

shld:	getaddr2(pseudopc)			| 22 SHLD addr
	lbu $2,regh(regs)
	addu $3,$3,targbase
	sb $2,1($3)
	lbu $2,regl(regs)
	sb $2,0($3)
	next

inxh:	lhu $3,regh(regs)			| 23 INX H
	addu $3,$3,regcon01
	sh $3,regh(regs)
	next

inrh:	lbu $3,regh(regs)			| 24 INR H
	inrflag($3)
	sb $3,regh(regs)
	next

dcrh:	lbu $3,regh(regs)			| 25 DCR H
	dcrflag($3)
	sb $3,regh(regs)
	next

mvih:	lbu $3,0(pseudopc)			| 26 MVI H,nn
	addu pseudopc,pseudopc,regcon01
	sb $3,regh(regs)
	next

daa:	andi $2,regf,1				| 27 DAA
	li $3,0
	bne $2,$0,fullcy
	slti $2,rega,0x9A
	beq $2,$0,nofull
fullcy:	ori $3,$3,0x60
nofull:	andi $2,regf,0x10
	bne $2,$0,halfcy
	andi $2,rega,0x0F
	slti $2,$2,0x0A
	beq $2,$0,nohalf
halfcy:	ori $3,$3,0x06
nohalf:	sll $2,rega,8
	or $3,$3,$2
#ifdef Z80
	andi $2,regf,2
	beq $2,$0,daap
daan:	xori $3,$3,0xFF		| Negative DAA
	sll $2,regcon01,16
	or $3,$3,$2
	addu $2,$3,aflagptr
	lbu regf,0($2)
	andi regf,regf,0xFB
	addu $2,$3,sumptr
	lbu rega,0($2)
	xor regf,regf,regcon01
	addu $2,$3,lflagptr
	lbu $3,0($2)
	andi $3,$3,4
	or regf,regf,$3
	next
daap:
#endif
	addu $2,$3,aflagptr	| Positive DAA
	lbu regf,0($2)
	andi regf,regf,0xFB
	addu $2,$3,sumptr
	lbu rega,0($2)
	addu $2,$3,lflagptr
	lbu $3,0($2)
	andi $3,$3,4
	or regf,regf,$3
	next

jrz:
#ifdef Z80
	lb $2,0(pseudopc)			| 28 JRZ dd (Z-80)
	addu pseudopc,pseudopc,regcon01
	andi $3,regf,0x40
	beq $3,$0,dcxhx
	addu pseudopc,pseudopc,$2
	next
#else
	j badop					| 28 Illegal for 8080
	nop
#endif

dadh:	lhu $3,regh(regs)			| 29 DAD H
	addu $3,$3,$3
	sh $3,regh(regs)
	carryf($3)
	next

lhld:	getaddr2(pseudopc)			| 2A LHLD addr
	addu $3,$3,targbase
	lbu $2,1($3)
	sb $2,regh(regs)
	lbu $2,0($3)
	sh $2,regl(regs)
	next

dcxh:	lhu $3,regh(regs)			| 2B DCX H
	subu $3,$3,regcon01
	sh $3,regh(regs)
dcxhx:	next

inrl:	lbu $3,regl(regs)			| 2C INR L
	inrflag($3)
	sb $3,regl(regs)
	next

dcrl:	lbu $3,regl(regs)			| 2D DCR L
	dcrflag($3)
	sb $3,regl(regs)
	next

mvil:	lbu $3,0(pseudopc)			| 2E MVI L,nn
	addu pseudopc,pseudopc,regcon01
	sb $3,regl(regs)
	next

cma:	xori rega,rega,0xFF			| 2F CMA
#ifdef Z80
	ori regf,regf,0x12
#endif
	next

jrnc:
#ifdef Z80
	lb $2,0(pseudopc)			| 30 JRNC dd (Z-80)
	addu pseudopc,pseudopc,regcon01
	andi $3,regf,1
	bne $3,$0,lxisx
	addu pseudopc,pseudopc,$2
	next
#else
	j badop					| 30 Illegal for 8080
	nop
#endif

lxis:	getaddr2(pseudopc)			| 31 LXI S,nnnn
	addu pseudosp,targbase,$3
lxisx:	next

sta:	getaddr2(pseudopc)			| 32 STA addr
	addu $3,$3,targbase
	sb rega,0($3)
	next

inxs:	addu pseudosp,pseudosp,regcon01		| 33 INX S
	next

inrm:	lhu $4,regh(regs)			| 34 INR M
	addu $4,$4,targbase
	lbu $3,0($4)
	inrflag($3)
	sb $3,0($4)
	next

dcrm:	lhu $4,regh(regs)			| 35 DCR M
	addu $4,$4,targbase
	lbu $3,0($4)
	dcrflag($3)
	sb $3,0($4)
	next

mvim:	lhu $2,regh(regs)			| 36 MVI M,nn
	addu $2,$2,targbase
	lbu $3,0(pseudopc)
	addu pseudopc,pseudopc,regcon01
	sb $3,0($2)
	next

stc:	ori regf,regf,1				| 37 STC
	next

jrc:
#ifdef Z80
	lb $2,0(pseudopc)			| 38 JRC dd (Z-80)
	addu pseudopc,pseudopc,regcon01
	andi $3,regf,1		
	beq $3,$0,lxisx
	addu pseudopc,pseudopc,$2
	next
#else
	j badop					| 38 Illegal for 8080
	nop
#endif

dads:	subu $3,pseudosp,targbase		| 39 DAD S
	lhu $2,regh(regs)
	addu $3,$3,$2
	sh $3,regh(regs)
	carryf($3)
	next

lda:	getaddr2(pseudopc)			| 3A LDA addr
	addu $3,$3,targbase
	lbu rega,0($3)
	next

dcxs:	subu pseudosp,pseudosp,regcon01		| 3B DCX S
	next

inra:	inrflag(rega)				| 3C INR A
	next

dcra:	dcrflag(rega)				| 3D DCR A
	next

mvia:	lbu rega,0(pseudopc)			| 3E MVI A,nn
	addu pseudopc,pseudopc,regcon01
	next

cmc:	xor regf,regf,regcon01			| 3F CMC
	next

movebb:	next					| 40 MOV B,B

movebc:	lbu $3,regc(regs)			| 41 MOV B,C
	sb $3,regb(regs)
	next

movebd:	lbu $3,regd(regs)			| 42 MOV B,D
	sb $3,regb(regs)
	next

movebe:	lbu $3,rege(regs)			| 43 MOV B,E
	sb $3,regb(regs)
	next

movebh:	lbu $3,regh(regs)			| 44 MOV B,H
	sb $3,regb(regs)
	next

movebl:	lbu $3,regl(regs)			| 45 MOV B,L
	sb $3,regb(regs)
	next

movebm:	lhu $3,regh(regs)			| 46 MOV B,M
	addu $3,$3,targbase
	lbu $3,0($3)
	sb $3,regb(regs)
	next

moveba:	sb rega,regb(regs)			| 47 MOV B,A
	next

movecb:	lbu $3,regb(regs)			| 48 MOV C,B
	sb $3,regc(regs)
	next

movecc:	next					| 49 MOV C,C

movecd:	lbu $3,regd(regs)			| 4A MOV C,D
	sb $3,regc(regs)
	next

movece:	lbu $3,rege(regs)			| 4B MOV C,E
	sb $3,regc(regs)
	next

movech:	lbu $3,regh(regs)			| 4C MOV C,H
	sb $3,regc(regs)
	next

movecl:	lbu $3,regl(regs)			| 4D MOV C,L
	sb $3,regc(regs)
	next

movecm:	lhu $3,regh(regs)			| 4E MOV C,M
	addu $3,$3,targbase
	lbu $3,0($3)
	sb $3,regc(regs)
	next

moveca:	sb rega,regc(regs)			| 4F MOV C,A
	next

movedb:	lbu $3,regb(regs)			| 50 MOV D,B
	sb $3,regd(regs)
	next

movedc:	lbu $3,regc(regs)			| 51 MOV D,C
	sb $3,regd(regs)
	next

movedd:	next					| 52 MOV D,D

movede:	lbu $3,rege(regs)			| 53 MOV D,E
	sb $3,regd(regs)
	next

movedh:	lbu $3,regh(regs)			| 54 MOV D,H
	sb $3,regd(regs)
	next

movedl:	lbu $3,regl(regs)			| 55 MOV D,L
	sb $3,regd(regs)
	next

movedm:	lhu $3,regh(regs)			| 56 MOV D,M
	addu $3,$3,targbase
	lbu $3,0($3)
	sb $3,regd(regs)
	next

moveda:	sb rega,regd(regs)			| 57 MOV D,A
	next

moveeb:	lbu $3,regb(regs)			| 58 MOV E,B
	sb $3,rege(regs)
	next

moveec:	lbu $3,regc(regs)			| 59 MOV E,C
	sb $3,rege(regs)
	next

moveed:	lbu $3,regd(regs)			| 5A MOV E,D
	sb $3,rege(regs)
	next

moveee:	next					| 5B MOV E,E

moveeh:	lbu $3,regh(regs)			| 5C MOV E,H
	sb $3,rege(regs)
	next

moveel:	lbu $3,regl(regs)			| 5D MOV E,L
	sb $3,rege(regs)
	next

moveem:	lhu $3,regh(regs)			| 5E MOV E,M
	addu $3,$3,targbase
	lbu $3,0($3)
	sb $3,rege(regs)
	next

moveea:	sb rega,rege(regs)			| 5F MOV E,A
	next

movehb:	lbu $3,regb(regs)			| 60 MOV H,B
	sb $3,regh(regs)
	next

movehc:	lbu $3,regc(regs)			| 61 MOV H,C
	sb $3,regh(regs)
	next

movehd:	lbu $3,regd(regs)			| 62 MOV H,D
	sb $3,regh(regs)
	next

movehe:	lbu $3,rege(regs)			| 63 MOV H,E
	sb $3,regh(regs)
	next

movehh:	next					| 64 MOV H,H

movehl:	lbu $3,regl(regs)			| 65 MOV H,L
	sb $3,regh(regs)
	next

movehm:	lhu $3,regh(regs)			| 66 MOV H,M
	addu $3,$3,targbase
	lbu $3,0($3)
	sb $3,regh(regs)
	next

moveha:	sb rega,regh(regs)			| 67 MOV H,A
	next

movelb:	lbu $3,regb(regs)			| 68 MOV L,B
	sb $3,regl(regs)
	next

movelc:	lbu $3,regc(regs)			| 69 MOV L,C
	sb $3,regl(regs)
	next

moveld:	lbu $3,regd(regs)			| 6A MOV L,D
	sb $3,regl(regs)
	next

movele:	lbu $3,rege(regs)			| 6B MOV L,E
	sb $3,regl(regs)
	next

movelh:	lbu $3,regh(regs)			| 6C MOV L,H
	sb $3,regl(regs)
	next

movell:	next					| 6D MOV L,L

movelm:	lhu $3,regh(regs)			| 6E MOV L,M
	addu $3,$3,targbase
	lbu $3,0($3)
	sb $3,regl(regs)
	next

movela:	sb rega,regl(regs)			| 6F MOV L,A
	next

movemb:	lhu $3,regh(regs)			| 70 MOV M,B
	addu $3,$3,targbase
	lbu $2,regb(regs)
	sb $2,0($3)
	next

movemc:	lhu $3,regh(regs)			| 71 MOV M,C
	addu $3,$3,targbase
	lbu $2,regc(regs)
	sb $2,0($3)
	next

movemd:	lhu $3,regh(regs)			| 72 MOV M,D
	addu $3,$3,targbase
	lbu $2,regd(regs)
	sb $2,0($3)
	next

moveme:	lhu $3,regh(regs)			| 73 MOV M,E
	addu $3,$3,targbase
	lbu $2,rege(regs)
	sb $2,0($3)
	next

movemh:	lhu $3,regh(regs)			| 74 MOV M,H
	addu $3,$3,targbase
	lbu $2,regh(regs)
	sb $2,0($3)
	next

movml:	lhu $3,regh(regs)			| 75 MOV M,L
	addu $3,$3,targbase
	lbu $2,regl(regs)
	sb $2,0($3)
	next

halt:	move ret1,$ra				| 76 HLT
	jal srvc
	move $ra,ret1
	next

movema:	lhu $3,regh(regs)			| 77 MOV M,A
	addu $3,$3,targbase
	sb rega,0($3)
	next

moveab:	lbu rega,regb(regs)			| 78 MOV A,B
	next

moveac:	lbu rega,regc(regs)			| 79 MOV A,C
	next

movead:	lbu rega,regd(regs)			| 7A MOV A,D
	next

moveae:	lbu rega,rege(regs)			| 7B MOV A,E
	next

moveah:	lbu rega,regh(regs)			| 7C MOV A,H
	next

moveal:	lbu rega,regl(regs)			| 7D MOV A,L
	next

moveam:	lhu $3,regh(regs)			| 7E MOV A,M
	addu $3,$3,targbase
	lbu rega,0($3)
	next

moveaa:	next					| 7F MOV A,A

addab:	lbu $3,regb(regs)			| 80 ADD B
	addflags
	next

addc:	lbu $3,regc(regs)			| 81 ADD C
	addflags
	next

addd:	lbu $3,regd(regs)			| 82 ADD D
	addflags
	next

adde:	lbu $3,rege(regs)			| 83 ADD E
	addflags
	next

addh:	lbu $3,regh(regs)			| 84 ADD H
	addflags
	next

addal:	lbu $3,regl(regs)			| 85 ADD L
	addflags
	next

addm:	lhu $3,regh(regs)			| 86 ADD M
	addu $3,$3,targbase
	lbu $3,0($3)
	addflags
	next

addaa:	andi $3,rega,0xFF			| 87 ADD A
	addflags
	next

adcb:	lbu $3,regb(regs)			| 88 ADC B
	adcflags
	next

adcc:	lbu $3,regc(regs)			| 89 ADC C
	adcflags
	next

adcd:	lbu $3,regd(regs)			| 8A ADC D
	adcflags
	next

adce:	lbu $3,rege(regs)			| 8B ADC E
	adcflags
	next

adch:	lbu $3,regh(regs)			| 8C ADC H
	adcflags
	next

adcl:	lbu $3,regl(regs)			| 8D ADC L
	adcflags
	next

adcm:	lhu $3,regh(regs)			| 8E ADC M
	addu $3,$3,targbase
	lbu $3,0($2)
	adcflags
	next

adca:	andi $3,rega,0xFF			| 8F ADC A
	adcflags
	next

subab:	lbu $3,regb(regs)			| 90 SUB B
	subflags
	next

subc:	lbu $3,regc(regs)			| 91 SUB C
	subflags
	next

subd:	lbu $3,regd(regs)			| 92 SUB D
	subflags
	next

sube:	lbu $3,rege(regs)			| 93 SUB E
	subflags
	next

subh:	lbu $3,regh(regs)			| 94 SUB H
	subflags
	next

subal:	lbu $3,regl(regs)			| 95 SUB L
	subflags
	next

subm:	lhu $3,regh(regs)			| 96 SUB M
	addu $3,$3,targbase
	lbu $3,0($3)
	subflags
	next

subaa:	andi $3,rega,0xFF			| 97 SUB A
	subflags
	next

sbbb:	lbu $3,regb(regs)			| 98 SBB B
	sbbflags
	next

sbbc:	lbu $3,regc(regs)			| 99 SBB C
	sbbflags
	next

sbbd:	lbu $3,regd(regs)			| 9A SBB D
	sbbflags
	next

sbbe:	lbu $3,rege(regs)			| 9B SBB E
	sbbflags
	next

sbbh:	lbu $3,regh(regs)			| 9C SBB H
	sbbflags
	next

sbbl:	lbu $3,regl(regs)			| 9D SBB L
	sbbflags
	next

sbbm:	lhu $3,regh(regs)			| 9E SBB M
	addu $3,$3,targbase
	lbu $3,0($3)
	sbbflags
	next

sbba:	andi $3,rega,0xFF			| 9F SBB A
	sbbflags
	next

anab:	lbu $3,regb(regs)			| A0 ANA B
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

andc:	lbu $3,regc(regs)			| A1 ANA C
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

andd:	lbu $3,regd(regs)			| A2 ANA D
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

ande:	lbu $3,rege(regs)			| A3 ANA E
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

andh:	lbu $3,regh(regs)			| A4 ANA H
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

anal:	lbu $3,regl(regs)			| A5 ANA L
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

andm:	lhu $3,regh(regs)			| A6 ANA M
	addu $3,$3,targbase
	lbu $3,0($3)
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

anda:	addu $3,lflagptr,rega			| A7 ANA A
	lbu regf,0($3)
	next

xrab:	lbu $3,regb(regs)			| A8 XRA B
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

xrac:	lbu $3,regc(regs)			| A9 XRA C
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

xrad:	lbu $3,regd(regs)			| AA XRA D
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

xrae:	lbu $3,rege(regs)			| AB XRA E
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

xrah:	lbu $3,regh(regs)			| AC XRA H
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

xral:	lbu $3,regl(regs)			| AD XRA L
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

xram:	lhu $3,regh(regs)			| AE XRA M
	addu $3,$3,targbase
	lbu $3,0($3)
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

xraa:	xor rega,rega,rega			| AF XRA A
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

orab:	lbu $3,regb(regs)			| B0 ORA B
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

orac:	lbu $3,regc(regs)			| B1 ORA C
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

orad:	lbu $3,regd(regs)			| B2 ORA D
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

orae:	lbu $3,rege(regs)			| B3 ORA E
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

orah:	lbu $3,regh(regs)			| B4 ORA H
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

oral:	lbu $3,regl(regs)			| B5 ORA L
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

oram:	lhu $3,regh(regs)			| B6 ORA M
	addu $3,$3,targbase
	lbu $3,0($3)
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

oraa:	addu $3,lflagptr,rega			| B7 ORA A
	lbu regf,0($3)
	next

cmpab:	lbu $3,regb(regs)			| B8 CMP B
	cmpflags
	next

cmpc:	lbu $3,regc(regs)			| B9 CMP C
	cmpflags
	next

cmpd:	lbu $3,regd(regs)			| BA CMP D
	cmpflags
	next

cmpe:	lbu $3,rege(regs)			| BB CMP E
	cmpflags
	next

cmph:	lbu $3,regh(regs)			| BC CMP H
	cmpflags
	next

cmpal:	lbu $3,regl(regs)			| BD CMP L
	cmpflags
	next

cmpam:	lhu $3,regh(regs)			| BE CMP M
	addu $3,$3,targbase
	lbu $3,0($3)
	cmpflags
	next

cmpaa:	andi $3,rega,0xFF			| BF CMP A
	cmpflags
	next

rnz:	andi $3,regf,0x40			| C0 RNZ
	bne $3,$0,rnz2
ret:	getaddr2(pseudosp)			| C9 RET
	addu pseudopc,targbase,$3
rnz2:	next


popb:	lbu $3,0(pseudosp)			| C1 POP B
	sb $3,regc(regs)
	lbu $3,1(pseudosp)
	addiu pseudosp,pseudosp,2
	sb $3,regb(regs)
	next

jnz:	andi $2,regf,0x40			| C2 JNZ addr
	getaddr2(pseudopc)
	bne $2,$0,jnz2
	addu pseudopc,targbase,$3
jnz2:	next

jmpa:	getaddr(pseudopc)			| C3 JMP addr
	addu pseudopc,targbase,$3
	next

cnz:	andi $2,regf,0x40			| C4 CNZ addr
	getaddr2(pseudopc)
	bne $2,$0,cnz2
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cnz2:	next

pushb:	lbu $3,regb(regs)			| C5 PUSH B
	sb $3,-1(pseudosp)
	lbu $3,regc(regs)
	sb $3,-2(pseudosp)
	addiu pseudosp,pseudosp,-2
	next

adi:	lbu $3,0(pseudopc)			| C6 ADI nn
	addu pseudopc,pseudopc,regcon01
	addflags
	next

rst0:	subu $2,pseudopc,targbase		| C7 RST 0
	putaddr
	addiu pseudopc,targbase,0
	next

rz:	andi $3,regf,0x40			| C8 RZ
	beq $3,$0,rz2
	getaddr2(pseudosp)
	addu pseudopc,targbase,$3
rz2:	next

jz:	andi $2,regf,0x40			| CA JZ addr
	getaddr2(pseudopc)
	beq $2,$0,jz2
	addu pseudopc,targbase,$3
jz2:	next

preCB:
#ifdef Z80
#  ifdef TRACE
	lbu $2,0(pseudopc)	| Tote up the cycles used.
	addiu $3,lflagptr,cycletabl1-lflags
	addu $3,$3,$2
	lbu $3,0($3)
	lw $4,cycles(regs)
	addu $4,$4,$3
	sw $4,cycles(regs)
	lw $3,opcntrs1(regs)
	sll $2,$2,2
	addu $3,$3,$2	| Increment the right opcode counter.
	lw $4,0($3)
	addu $4,$4,regcon01
	sw $4,0($3)
#  endif
	la $3,CBoptab				| CB Prefix for BIT instrs.
	nextr3
#else /* Not Z80 */
	j badop					| CB Illegal for 8080
	nop
#endif /* Z80 */

cz:	andi $2,regf,0x40			| CC CZ addr
	getaddr2(pseudopc)
	beq $2,$0,cz2
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cz2:	next

call:	getaddr2(pseudopc)			| CD CALL addr
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
	next

aci:	lbu $3,0(pseudopc)			| CE ACI nn
	addu pseudopc,pseudopc,regcon01
	adcflags
	next

rst8:	subu $2,pseudopc,targbase		| CF RST 8
	putaddr
	addiu pseudopc,targbase,8
	next

rnc:	andi $3,regf,1				| D0 RNC
	bne $3,$0,rnc2
	getaddr2(pseudosp)
	addu pseudopc,targbase,$3
rnc2:	next

popd:	lbu $3,0(pseudosp)			| D1 POP D
	sb $3,rege(regs)
	lbu $3,1(pseudosp)
	addiu pseudosp,pseudosp,2
	sb $3,regd(regs)
	next

jnc:	andi $2,regf,1				| D2 JNC addr
	getaddr2(pseudopc)
	bne $2,$0,jnc2
	addu pseudopc,targbase,$3
jnc2:	next

out:	addu pseudopc,pseudopc,regcon01		| D3 OUT nn
	next

cnc:	andi $2,regf,1				| D4 CNC addr
	getaddr2(pseudopc)
	bne $2,$0,cnc2
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cnc2:	next

pushd:	lbu $3,regd(regs)			| D5 PUSH D
	sb $3,-1(pseudosp)
	lbu $3,rege(regs)
	sb $3,-2(pseudosp)
	addiu pseudosp,pseudosp,-2
	next

sui:	lbu $3,0(pseudopc)			| D6 SUI nn
	addu pseudopc,pseudopc,regcon01
	subflags
	next

rst10:	subu $2,pseudopc,targbase		| D7 RST 10
	putaddr
	addiu pseudopc,targbase,16
	next

rc:	andi $3,regf,1				| D8 RC
	beq $3,$0,rc2
	getaddr2(pseudosp)
	addu pseudopc,targbase,$3
rc2:	next

exx:
#ifdef Z80
	lhu $3,regb(regs)			| D9 EXX (Z-80)
	lhu $2,regb2(regs)
	sh $2,regb(regs)
	sh $3,regb2(regs)
	lw $3,regd(regs)	| Gets HL too.
	lw $2,regd2(regs)
	sw $2,regd(regs)
	sw $3,regd2(regs)
	next
#else
	j badop					| D9 Illegal for 8080
	nop
#endif

jc:	andi $2,regf,1				| DA JC addr
	getaddr2(pseudopc)
	beq $2,$0,jc2
	addu pseudopc,targbase,$3
jc2:	next

in:	addu pseudopc,pseudopc,regcon01		| DB IN nn
	next

cc1:	andi $2,regf,1				| DC CC addr
	getaddr2(pseudopc)
	beq $2,$0,cc2
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cc2:	next

preDD:
#ifdef Z80
#  ifdef TRACE
	lbu $2,0(pseudopc)	| Tote up the cycles used.
	addiu $3,lflagptr,cycletabl2-lflags
	addu $3,$3,$2
	lbu $3,0($3)
	lw $4,cycles(regs)
	addu $4,$4,$3
	sw $4,cycles(regs)
	lw $3,opcntrs2(regs)
	sll $2,$2,2
	addu $3,$3,$2	| Increment the right opcode counter.
	lw $4,0($3)
	addu $4,$4,regcon01
	sw $4,0($3)
#  endif
	la $3,DDoptab				| DD Prefix for IX instrs
	nextr3
#else /* Not Z80 */
	j badop					| DD Illegal for 8080
	nop
#endif /* Z80 */

sbi:	lbu $3,0(pseudopc)			| DE SBI nn
	addu pseudopc,pseudopc,regcon01
	sbbflags
	next

rst18:	subu $2,pseudopc,targbase		| DF RST 18
	putaddr
	addiu pseudopc,targbase,24
	next

rpo:	andi $3,regf,4				| E0 RPO
	bne $3,$0,rpo2
	getaddr2(pseudosp)
	addu pseudopc,targbase,$3
rpo2:	next

poph:	lbu $3,0(pseudosp)			| E1 POP H
	sb $3,regl(regs)
	lbu $3,1(pseudosp)
	addiu pseudosp,pseudosp,2
	sb $3,regh(regs)
	next

jpo:	andi $2,regf,4				| E2 JPO addr
	getaddr2(pseudopc)
	bne $2,$0,jpo2
	addu pseudopc,targbase,$3
jpo2:	next

xthl:	lbu $2,regh(regs)			| E3 XTHL
	lbu $3,0(pseudosp)
	sb $2,0(pseudosp)
	sb $3,regh(regs)
	lbu $2,regl(regs)
	lbu $3,1(pseudosp)
	sb $2,1(pseudosp)
	sb $3,regl(regs)
	next

cpo:	andi $2,regf,4				| E4 CPO addr
	getaddr2(pseudopc)
	bne $2,$0,cpo2
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cpo2:	next


pushh:	lbu $3,regh(regs)			| E5 PUSH H
	sb $3,-1(pseudosp)
	lbu $3,regl(regs)
	sb $3,-2(pseudosp)
	addiu pseudosp,pseudosp,-2
	next

ani:	lbu $3,0(pseudopc)			| E6 ANI nn
	addu pseudopc,pseudopc,regcon01
	and rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

rst20:	subu $2,pseudopc,targbase		| E7 RST 20
	putaddr
	addiu pseudopc,targbase,32
	next

rpe:	andi $3,regf,4				| E8 RPE
	beq $3,$0,rpe2
	getaddr2(pseudosp)
	addu pseudopc,targbase,$3
rpe2:	next

pchl:	lhu $3,regh(regs)			| E9 PCHL
	addu pseudopc,targbase,$3
	next

jpe:	andi $2,regf,4				| EA JPE addr
	getaddr2(pseudopc)
	beq $2,$0,jpe2
	addu pseudopc,targbase,$3
jpe2:	next

xchg:	lhu $3,regd(regs)			| EB XCHG
	lhu $2,regh(regs)
	sh $2,regd(regs)
	sh $3,regh(regs)
	next

cpe:	andi $2,regf,4				| EC CPE addr
	getaddr2(pseudopc)
	beq $2,$0,cpe2
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cpe2:	next

preED:						| ED Prefix for misc instrs.
#ifdef Z80
#  ifdef TRACE
	lbu $2,0(pseudopc)	| Tote up the cycles used.
	addiu $3,lflagptr,cycletabl3-lflags
	addu $3,$3,$2
	lbu $3,0($3)
	lw $4,cycles(regs)
	addu $4,$4,$3
	sw $4,cycles(regs)
	lw $3,opcntrs3(regs)
	sll $2,$2,2
	addu $3,$3,$2	| Increment the right opcode counter.
	lw $4,0($3)
	addu $4,$4,regcon01
	sw $4,0($3)
#  endif
	la $3,EDoptab
	nextr3
#else /* Not Z80 */
	j badop					| ED Illegal for 8080
	nop
#endif /* Z80 */

xri:	lbu $3,0(pseudopc)			| EE XRI nn
	addu pseudopc,pseudopc,regcon01
	xor rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

rst28:	subu $2,pseudopc,targbase		| EF RST 28
	putaddr
	addi pseudopc,targbase,40
	next

rp:	andi $3,regf,0x80			| F0 RP
	bne $3,$0,rp2
	getaddr2(pseudosp)
	addu pseudopc,targbase,$3
rp2:	next

popp:	lbu regf,0(pseudosp)			| F1 POP P
	lbu rega,1(pseudosp)
	addiu pseudosp,pseudosp,2
	next

jp:	andi $2,regf,0x80			| F2 JP addr
	getaddr2(pseudopc)
	bne $2,$0,jp2
	addu pseudopc,targbase,$3
jp2:	next

di:						| F3 DI
#ifdef Z80
	sb $0,regiff(regs)
#endif
	next

cp:	andi $2,regf,0x80			| F4 CP addr
	getaddr2(pseudopc)
	bne $2,$0,cp2
	subu $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cp2:	next

pushp:	sb rega,-1(pseudosp)			| F5 PUSH P
	sb regf,-2(pseudosp)
	addiu pseudosp,pseudosp,-2
	next

oria:	lbu $3,0(pseudopc)			| F6 ORI nn
	addu pseudopc,pseudopc,regcon01
	or rega,rega,$3
	addu $3,lflagptr,rega
	lbu regf,0($3)
	next

rst30:	sub $2,pseudopc,targbase		| F7 RST 30
	putaddr
	addi pseudopc,targbase,48
	next

rm:	andi $3,regf,0x80			| F8 RM
	beq $3,$0,rm2
	getaddr2(pseudosp)
	addu pseudopc,targbase,$3
rm2:	next

sphl:	lhu $3,regh(regs)			| F9 SPHL
	addu pseudosp,targbase,$3
	next

jm:	andi $2,regf,0x80			| FA JM addr
	getaddr2(pseudopc)
	beq $2,$0,jm2
	addu pseudopc,targbase,$3
jm2:	next

ei:						| FB EI
#ifdef Z80
	ori $3,$0,4
	sb $3,regiff(regs)
#endif
	next

cm:	andi $2,regf,0x80			| FC CM addr
	getaddr2(pseudopc)
	beq $2,$0,cm2
	sub $2,pseudopc,targbase
	putaddr
	addu pseudopc,targbase,$3
cm2:	next

preFD:
#ifdef Z80
#  ifdef TRACE
	lbu $2,0(pseudopc)	| Tote up the cycles used.
	addiu $3,lflagptr,cycletabl4-lflags
	addu $3,$3,$2
	lbu $3,0($3)
	lw $4,cycles(regs)
	addu $4,$4,$3
	sw $4,cycles(regs)
	lw $3,opcntrs4(regs)
	sll $2,$2,2
	addu $3,$3,$2	| Increment the right opcode counter.
	lw $4,0($3)
	addu $4,$4,regcon01
	sw $4,0($3)
#  endif
	la $3,FDoptab				| FD Prefix for IY instrs
	nextr3
#else /* Not Z80 */
	j badop					| FD Illegal for 8080
	nop
#endif /* Z80 */

cpi:	lbu $3,0(pseudopc)			| FE CPI nn
	addu pseudopc,pseudopc,regcon01
	cmpflags
	next

rst38:	subu $2,pseudopc,targbase		| FF RST 38
	putaddr
	addiu pseudopc,targbase,56
	next

|***********************************************************************|
|									|
|	Initialization and Main Opcode dispatcher.			|
|									|
|***********************************************************************|

#ifdef TRACE
#  ifdef CONTEST
	.globl oopcodesimulator
	.ent	oopcodesimulator
	.type	oopcodesimulator, @function
oopcodesimulator:
#  else
	.globl opcodesimulator
	.ent	opcodesimulator
	.type	opcodesimulator, @function
opcodesimulator:
#  endif
#else
	.globl opcodesimulator
	.ent	opcodesimulator
	.type	opcodesimulator, @function
opcodesimulator:
#endif
	.frame	$sp,20*4,$31
	.cpload	$1

	addiu	$sp,$sp,-20*4	| Local stack frame
	sw	$ra,14*4($sp)	| Save return address
	sw	$fp,13*4($sp)
	sw	$28,12*4($sp)

	sw	pseudopc,11*4($sp)
	sw	pseudosp,10*4($sp)
	sw	targbase,9*4($sp)
	sw	ret1,8*4($sp)
	sw	ret2,7*4($sp)
	sw	regf,6*4($sp)
	sw	rega,5*4($sp)

	move	$fp,$sp

	move	targbase,$4	| Start of target memory (TPA).
	jal	lodregs		| Load the remaining simulation registers.
	nop
	jal	mloop2
	nop
	jal	filsh2		| Make shadow registers valid.
	nop

	move	$sp,$fp
	lw	$ra,14*4($sp)
	lw	$fp,13*4($sp)
	lw	$28,12*4($sp)
	lw	pseudopc,11*4($sp)
	lw	pseudosp,10*4($sp)
	lw	targbase,9*4($sp)
	lw	ret1,8*4($sp)
	lw	ret2,7*4($sp)
	lw	regf,6*4($sp)
	lw	rega,5*4($sp)
	addiu	$sp,$sp,20*4
	jr	$ra
	nop
|				| Execute simulation
mloop:
#ifdef TRACE
#  ifdef CONTEST
	jr $ra
#  else
	lbu $2,badflag(regs)
	bne $2,$0,mloop2
	lw $2,pppctmp(regs)
	sw $2,pppc(regs)
#  endif
#endif
mloop2:
#ifdef TRACE
	addu $2,pseudopc,regcon01
	sw $2,pppctmp(regs)
	lbu $2,trcflag(regs)	| Optional trace.
	bne $2,$0,dotrace
	lw $2,trcbegin(regs)
	bne $2,pseudopc,notrace
	sb regcon01,trcflag(regs)
dotrace: move ret1,$ra
	jal step
	move $ra,ret1
	lw $2,trcend(regs)
	bne $2,pseudopc,notrace
	sb $0,trcflag(regs)
notrace:
	lbu $2,0(pseudopc)	| Tote up the cycles used.
	addiu $3,lflagptr,cycletabl-lflags
	addu $3,$3,$2
	lbu $3,0($3)
	lw $4,cycles(regs)
	addu $4,$4,$3
	sw $4,cycles(regs)
	lw $3,opcntrs(regs)
	sll $2,$2,2
	addu $3,$3,$2	| Increment the right opcode counter.
	lw $4,0($3)
	addu $4,$4,regcon01
	sw $4,0($3)
#endif /* TRACE */

	inext			| Execute the appropriate subroutine.

|***********************************************************************|
|									|
|	Illegal instructions and Dumping.				|
|									|
|***********************************************************************|

filshad: move $2,pseudopc		| Make shadow registers valid.
filsh2:	sw $2,ppc(targbase)
	subu $2,$2,targbase
	sh $2,spchi(targbase)

	addu $2,pseudosp,regcon01
	sw $2,psp(targbase)
	sub $2,$2,targbase
	sh $2,ssphi(targbase)

	sb rega,srega(targbase)
	sb regf,sregf(targbase)

	sw opptr,0*4($fp)		| Save off scratch registers.
	sw lflagptr,1*4($fp)
	sw aflagptr,2*4($fp)
	sw sflagptr,3*4($fp)
	sw sumptr,4*4($fp)

	jr $ra
	nop

| Handle illegal instructions by printing a message, the 8080/Z-80 registers,
| and exiting the simulation.

badop:	move ret1,$ra		| Save return address from harm.
	sb regcon01,badflag(targbase)
	jal filshad
	nop
	move $4,targbase
	lw $1,%call16(illegal)($28)
	jalr $1			| Call the C guts spiller.
	nop
	jr ret1			| Return to that which called mloop.
	nop

step:	addu $2,pseudopc,regcon01 | Make shadow registers valid.
	move ret2,$ra		| Save return address from harm.
	jal filsh2
	nop
	move $3,targbase
	lw $1,%call16(stepper)($28)
	jalr $1			| Call the 8080/Z-80 stepper/state dumper.
	nop
	lw opptr,0*4($fp)	| Repair damage to scratch registers.
	lw lflagptr,1*4($fp)
	lw aflagptr,2*4($fp)
	lw sflagptr,3*4($fp)
	lw sumptr,4*4($fp)
	li regcon01,1
	li regconm1,-1
	jr ret2
	nop

|***********************************************************************|
|									|
|	Set up the processor registers used by the simulation.		|
|									|
|***********************************************************************|

lodregs:
	la opptr,optabl		| Point base reg. to opcode dispatch table.
	la aflagptr,aflags	| Flag conversion tables.
	la sflagptr,sflags
	la lflagptr,lflags
	la sumptr,sums
	lw pseudopc,ppc(targbase)	| Starting Pseudo-PC
	lw pseudosp,psp(targbase)	| Starting Pseudo-SP
	li regcon01,1			| Set up quick constants.
	li regconm1,-1
	lbu rega,srega(targbase)	| Clear 8080/Z-80 accumulator.
	lbu regf,sregf(targbase)
	jr $ra
	nop

|***********************************************************************|
|									|
|	BIOS and BDOS service request handler.  Calls out to C.		|
|									|
|***********************************************************************|

srvc:	move ret2,$ra		| Save return address from harm.
	jal filshad		| Load up the shadow 'registers'.
	move $4,targbase
	lw $1,%call16(service)($28)
	jalr $1			| Call the C BDOS->Unix converter.
	nop
	addu pseudopc,pseudopc,regcon01	| Move past service opcode.
	lbu rega,srega(targbase)	| Get the call results.
	addu regf,lflagptr,rega
	lbu regf,0(regf)
	lw opptr,0*4($fp)		| Repair damage to scratch registers.
	lw lflagptr,1*4($fp)
	lw aflagptr,2*4($fp)
	lw sflagptr,3*4($fp)
	lw sumptr,4*4($fp)
	li regcon01,1
	li regconm1,-1
	jr ret2
	nop

|***********************************************************************|
|									|
|	Opcode dispatch table.  One entry per opcode of the target 	|
|	(8080) processor, including illegals.				|
|									|
|***********************************************************************|

	.align 4
optabl:	entry nop00,lxib,staxb,inxb,inrb,dcrb,mvib,rlca
	entry exaf,dadb,ldaxb,dcxb,inrc,dcrc,mvic,rrca
	entry djnz,lxid,staxd,inxd,inrd,dcrd,mvid,ral
	entry jr,dadd,ldaxd,dcxd,inre,dcre,mvie,rar
	entry jrnz,lxih,shld,inxh,inrh,dcrh,mvih,daa
	entry jrz,dadh,lhld,dcxh,inrl,dcrl,mvil,cma
	entry jrnc,lxis,sta,inxs,inrm,dcrm,mvim,stc
	entry jrc,dads,lda,dcxs,inra,dcra,mvia,cmc
	entry movebb,movebc,movebd,movebe,movebh,movebl,movebm,moveba
	entry movecb,movecc,movecd,movece,movech,movecl,movecm,moveca
	entry movedb,movedc,movedd,movede,movedh,movedl,movedm,moveda
	entry moveeb,moveec,moveed,moveee,moveeh,moveel,moveem,moveea
	entry movehb,movehc,movehd,movehe,movehh,movehl,movehm,moveha
	entry movelb,movelc,moveld,movele,movelh,movell,movelm,movela
	entry movemb,movemc,movemd,moveme,movemh,movml,halt,movema
	entry moveab,moveac,movead,moveae,moveah,moveal,moveam,moveaa
	entry addab,addc,addd,adde,addh,addal,addm,addaa
	entry adcb,adcc,adcd,adce,adch,adcl,adcm,adca
	entry subab,subc,subd,sube,subh,subal,subm,subaa
	entry sbbb,sbbc,sbbd,sbbe,sbbh,sbbl,sbbm,sbba
	entry anab,andc,andd,ande,andh,anal,andm,anda
	entry xrab,xrac,xrad,xrae,xrah,xral,xram,xraa
	entry orab,orac,orad,orae,orah,oral,oram,oraa
	entry cmpab,cmpc,cmpd,cmpe,cmph,cmpal,cmpam,cmpaa
	entry rnz,popb,jnz,jmpa,cnz,pushb,adi,rst0
	entry rz,ret,jz,preCB,cz,call,aci,rst8
	entry rnc,popd,jnc,out,cnc,pushd,sui,rst10
	entry rc,exx,jc,in,cc1,preDD,sbi,rst18
	entry rpo,poph,jpo,xthl,cpo,pushh,ani,rst20
	entry rpe,pchl,jpe,xchg,cpe,preED,xri,rst28
	entry rp,popp,jp,di,cp,pushp,oria,rst30
	entry rm,sphl,jm,ei,cm,preFD,cpi,rst38

	.eject
#ifdef Z80
	.globl prDDCB,prFDCB,illgED,ilDDCB,mloop
prDDCB:
#  ifdef TRACE
	lbu $2,0(pseudopc)	| Tote up the cycles used.
	addiu $3,lflagptr,cycletabl5-lflags
	addu $3,$3,$2
	lbu $3,0($3)
	lw $4,cycles(regs)
	addu $4,$4,$3
	sw $4,cycles(regs)
	lw $3,opcntrs5(regs)
	sll $2,$2,2
	addu $3,$3,$2	| Increment the right opcode counter.
	lw $4,0($3)
	addu $4,$4,regcon01
	sw $4,0($3)
#  endif
	calcind(regix)			| Calculate operand address.
pDDCBs:	lbu $4,0(pseudopc)		| Sub-sub-opcode
	addu pseudopc,pseudopc,regcon01
	andi $3,$4,7
	ori $1,$0,6			| Is it valid?
	bne $3,$1,ilDDCB 		| No.
	srl $4,$4,1			| Kill low-order 3 bits, 32-bit disp.
	andi $4,$4,0xFC
	la $3,DDCBopt
	addu $3,$3,$4
	lw $3,0($3)
	jr $3
	nop

prFDCB:
#  ifdef TRACE
	lbu $2,0(pseudopc)	| Tote up the cycles used.
	addiu $3,lflagptr,cycletabl6-lflags
	addu $3,$3,$2
	lbu $3,0($3)
	lw $4,cycles(regs)
	addu $4,$4,$3
	sw $4,cycles(regs)
	lw $3,opcntrs6(regs)
	sll $2,$2,2
	addu $3,$3,$2	| Increment the right opcode counter.
	lw $4,0($3)
	addu $4,$4,regcon01
	sw $4,0($3)
#  endif
	calcind(regiy)			| Calculate operand address.
	j pDDCBs	 		| Now we can use DDCB routines.
	nop

ilDDCB:	addiu pseudopc,pseudopc,-2 | Enter here for DDCB/FDCB prefix errors.

#endif /* !Z80 */

illgED:	addu pseudopc,pseudopc,regconm1	| Fix pseudo-PC for ILLEGAL.
	j badop
	nop

	.eject
|***********************************************************************|
|									|
|	Flag register lookup tables.					|
|									|
|***********************************************************************|

| These are large tables giving the AF results from A+B+C.  The MIPS has
| no native condition codes to translate, and it has gobs of memory.

#include "flags.s"

lflags:	.byte 0x44,0x00,0x00,0x04,0x00,0x04,0x04,0x00	| Logical flags.
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
	.byte 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
	.byte 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x00,0x04,0x04,0x00,0x04,0x00,0x00,0x04
	.byte 0x04,0x00,0x00,0x04,0x00,0x04,0x04,0x00
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x84,0x80,0x80,0x84,0x80,0x84,0x84,0x80
	.byte 0x80,0x84,0x84,0x80,0x84,0x80,0x80,0x84

#ifdef TRACE
| Table of cycle counts per 8080 instruction.  For those with two different
| times the times are averaged, unless (like DJNZ) you can assume that one
| time is dominant.
	.globl cycletabl,cycletabl1,cycletabl2,cycletabl3,cycletabl4
	.globl cycletabl5,cycletabl6
	.type	cycletabl, @object
	.type	cycletabl1, @object
	.type	cycletabl2, @object
	.type	cycletabl3, @object
	.type	cycletabl4, @object
	.type	cycletabl5, @object
	.type	cycletabl6, @object
cycletabl:
	.byte 4,10,7,6,4,4,7,4	| NOP,LXIB,STAXB,INXB,INRB,DCRB,MVIB,RLCA
	.byte 4,11,7,6,4,4,7,4	| EXAF,DADB,LDAXB,DCXB,INRC,DCRC,MVIC,RRCA
	.byte 13,10,7,6,4,4,7,4	| DJNZ,LXID,STAXD,INXD,INRD,DCRD,MVID,RAL
	.byte 12,11,7,6,4,4,7,4	| JR,DADD,LDAXD,DCXD,INRE,DCRE,MVIE,RAR
	.byte 9,10,16,6,4,4,7,4	| JRNZ,LXIH,SHLD,INXH,INRH,DCRH,MVIH,DAA
	.byte 9,11,16,6,4,4,7,4	| JRZ,DADH,LHLD,DCXH,INRL,DCRL,MVIL,CMA
	.byte 9,10,13,6,11,11,7,4 | JRNC,LXIS,STA,INXS,INRM,DCRM,MVIM,STC
	.byte 9,11,13,6,4,4,7,4	| JRC,DADS,LDA,DCXS,INRA,DCRA,MVIA,CMC
	.byte 4,4,4,4,4,4,7,4 | MOVBB,MOVBC,MOVBD,MOVBE,MOVBH,MOVBL,MOVBM,MOVBA
	.byte 4,4,4,4,4,4,7,4 | MOVCB,MOVCC,MOVCD,MOVCE,MOVCH,MOVCL,MOVCM,MOVCA
	.byte 4,4,4,4,4,4,7,4 | MOVDB,MOVDC,MOVDD,MOVDE,MOVDH,MOVDL,MOVDM,MOVDA
	.byte 4,4,4,4,4,4,7,4 | MOVEB,MOVEC,MOVED,MOVEE,MOVEH,MOVEL,MOVEM,MOVEA
	.byte 4,4,4,4,4,4,7,4 | MOVHB,MOVHC,MOVHD,MOVHE,MOVHH,MOVHL,MOVHM,MOVHA
	.byte 4,4,4,4,4,4,7,4 | MOVLB,MOVLC,MOVLD,MOVLE,MOVLH,MOVLL,MOVLM,MOVLA
	.byte 7,7,7,7,7,7,4,7 | MOVMB,MOVMC,MOVMD,MOVME,MOVMH,MOVML,HLT,MOVMA
	.byte 4,4,4,4,4,4,7,4 | MOVAB,MOVAC,MOVAD,MOVAE,MOVAH,MOVAL,MOVAM,MOVAA
	.byte 4,4,4,4,4,4,7,4	| ADDB,ADDC,ADDD,ADDE,ADDH,ADDL,ADDM,ADDA
	.byte 4,4,4,4,4,4,7,4	| ADCB,ADCC,ADCD,ADCE,ADCH,ADCL,ADCM,ADCA
	.byte 4,4,4,4,4,4,7,4	| SUBB,SUBC,SUBD,SUBE,SUBH,SUBL,SUBM,SUBA
	.byte 4,4,4,4,4,4,7,4	| SBBB,SBBC,SBBD,SBBE,SBBH,SBBL,SBBM,SBBA
	.byte 4,4,4,4,4,4,7,4	| ANDB,ANDC,ANDD,ANDE,ANDH,ANDL,ANDM,ANDA
	.byte 4,4,4,4,4,4,7,4	| XRAB,XRAC,XRAD,XRAE,XRAH,XRAL,XRAM,XRAA
	.byte 4,4,4,4,4,4,7,4	| ORAB,ORAC,ORAD,ORAE,ORAH,ORAL,ORAM,ORAA
	.byte 4,4,4,4,4,4,7,4	| CMPB,CMPC,CMPD,CMPE,CMPH,CMPL,CMPM,CMPA
	.byte 8,10,10,10,14,11,7,11 | RNZ,POPB,JNZ,JMP,CNZ,PUSHB,ADI,RST0
	.byte 8,10,10,0,14,17,7,11 | RZ,RET,JZ,BIT,CZ,CALL,ACI,RST8
	.byte 8,10,10,11,14,11,7,11 | RNC,POPD,JNC,OUT,CNC,PUSHD,SUI,RST10
	.byte 8,4,10,11,14,0,7,11 | RC,EXX,JC,IN,CC,IX,SBI,RST18
	.byte 8,10,10,19,14,11,7,11 | RPO,POPH,JPO,XTHL,CPO,PUSHH,ANI,RST20
	.byte 8,4,10,4,14,0,7,11 | RPE,PCHL,JPE,XCHG,CPE,MISC,XRI,RST28
	.byte 8,10,10,4,14,11,7,11 | RP,POPP,JP,DI,CP,PUSHP,ORI,RST30
	.byte 8,6,10,4,14,0,7,11 | RM,SPHL,JM,EI,CM,IY,CPI,RST38

| As above, for CBXX Z80 instructions.
cycletabl1:
	.byte 8,8,8,8,8,8,15,8	| RLCB,RLCC,RLCD,RLCE,RLCH,RLCL,RLCM,RLCA
	.byte 8,8,8,8,8,8,15,8	| RRCB,RRCC,RRCD,RRCE,RRCH,RRCL,RRCM,RRCA
	.byte 8,8,8,8,8,8,15,8	| RLB,RLC,RLD,RLE,RLH,RLL,RLM,RLA
	.byte 8,8,8,8,8,8,15,8	| RRB,RRC,RRD,RRE,RRH,RRL,RRM,RRA
	.byte 8,8,8,8,8,8,15,8	| SLAB,SLAC,SLAD,SLAE,SLAH,SLAL,SLAM,SLAA
	.byte 8,8,8,8,8,8,15,8	| SRAB,SRAC,SRAD,SRAE,SRAH,SRAL,SRAM,SRAA
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 8,8,8,8,8,8,15,8	| SRLB,SRLC,SRLD,SRLE,SRLH,SRLL,SRLM,SRLA
	.byte 8,8,8,8,8,8,12,8 |BIT0B,BIT0C,BIT0D,BIT0E,BIT0H,BIT0L,BIT0M,BIT0A
	.byte 8,8,8,8,8,8,12,8 |BIT1B,BIT1C,BIT1D,BIT1E,BIT1H,BIT1L,BIT1M,BIT1A
	.byte 8,8,8,8,8,8,12,8 |BIT2B,BIT2C,BIT2D,BIT2E,BIT2H,BIT2L,BIT2M,BIT2A
	.byte 8,8,8,8,8,8,12,8 |BIT3B,BIT3C,BIT3D,BIT3E,BIT3H,BIT3L,BIT3M,BIT3A
	.byte 8,8,8,8,8,8,12,8 |BIT4B,BIT4C,BIT4D,BIT4E,BIT4H,BIT4L,BIT4M,BIT4A
	.byte 8,8,8,8,8,8,12,8 |BIT5B,BIT5C,BIT5D,BIT5E,BIT5H,BIT5L,BIT5M,BIT5A
	.byte 8,8,8,8,8,8,12,8 |BIT6B,BIT6C,BIT6D,BIT6E,BIT6H,BIT6L,BIT6M,BIT6A
	.byte 8,8,8,8,8,8,12,8 |BIT7B,BIT7C,BIT7D,BIT7E,BIT7H,BIT7L,BIT7M,BIT7A
	.byte 8,8,8,8,8,8,15,8 |RES0B,RES0C,RES0D,RES0E,RES0H,RES0L,RES0M,RES0A
	.byte 8,8,8,8,8,8,15,8 |RES1B,RES1C,RES1D,RES1E,RES1H,RES1L,RES1M,RES1A
	.byte 8,8,8,8,8,8,15,8 |RES2B,RES2C,RES2D,RES2E,RES2H,RES2L,RES2M,RES2A
	.byte 8,8,8,8,8,8,15,8 |RES3B,RES3C,RES3D,RES3E,RES3H,RES3L,RES3M,RES3A
	.byte 8,8,8,8,8,8,15,8 |RES4B,RES4C,RES4D,RES4E,RES4H,RES4L,RES4M,RES4A
	.byte 8,8,8,8,8,8,15,8 |RES5B,RES5C,RES5D,RES5E,RES5H,RES5L,RES5M,RES5A
	.byte 8,8,8,8,8,8,15,8 |RES6B,RES6C,RES6D,RES6E,RES6H,RES6L,RES6M,RES6A
	.byte 8,8,8,8,8,8,15,8 |RES7B,RES7C,RES7D,RES7E,RES7H,RES7L,RES7M,RES7A
	.byte 8,8,8,8,8,8,15,8 |SET0B,SET0C,SET0D,SET0E,SET0H,SET0L,SET0M,SET0A
	.byte 8,8,8,8,8,8,15,8 |SET1B,SET1C,SET1D,SET1E,SET1H,SET1L,SET1M,SET1A
	.byte 8,8,8,8,8,8,15,8 |SET2B,SET2C,SET2D,SET2E,SET2H,SET2L,SET2M,SET2A
	.byte 8,8,8,8,8,8,15,8 |SET3B,SET3C,SET3D,SET3E,SET3H,SET3L,SET3M,SET3A
	.byte 8,8,8,8,8,8,15,8 |SET4B,SET4C,SET4D,SET4E,SET4H,SET4L,SET4M,SET4A
	.byte 8,8,8,8,8,8,15,8 |SET5B,SET5C,SET5D,SET5E,SET5H,SET5L,SET5M,SET5A
	.byte 8,8,8,8,8,8,15,8 |SET6B,SET6C,SET6D,SET6E,SET6H,SET6L,SET6M,SET6A
	.byte 8,8,8,8,8,8,15,8 |SET7B,SET7C,SET7D,SET7E,SET7H,SET7L,SET7M,SET7A

| As above, for DDXX Z80 instructions.
cycletabl2:
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,15,0,0,0,0,0,0	| -,DADXB,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,15,0,0,0,0,0,0	| -,DADXD,-,-,-,-,-,-
	.byte 0,14,20,10,9,9,9,0| -,LXIX,SIXD,INXX,INRXH,DCRXH,MVIXH,-
	.byte 0,15,20,10,9,9,9,0| -,DADXX,LIXD,DCXX,INRXL,DCRXL,MVIXL,-
	.byte 0,0,0,0,23,23,19,0| -,-,-,-,INRIX,DCRIX,MVIIX,-
	.byte 0,15,0,0,0,0,0,0	| -,DADXS,-,-,-,-,-,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVBXH,MOVBXL,MOVBIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVCXH,MOVCXL,MOVCIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVDXH,MOVDXL,MOVDIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVEXH,MOVEXL,MOVEIX,-
	.byte 9,9,9,9,9,9,19,9	| MOVXHB,MOVXHC,MOVXHD,MOVXHE,MOVXHXH,MOVXHXL,MOVXHIX,MOVXHA
	.byte 9,9,9,9,9,9,19,9	| MOVXLB,MOVXLC,MOVXLD,MOVXLE,MOVXLXH,MOVLHXL,MOLXHIX,MLVXHA
	.byte 19,19,19,19,19,19,0,19| MOVIXB,MOVIXC,MOVIXD,MOVIXE,MOVIXH,MOVIXL,-,MOVIXA
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVAXH,MOVAXL,MOVAIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ADDXH,ADDXL,ADDIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ADCXH,ADCXL,ADCIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,SUBXH,SUBXL,SUBIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,SBCXH,SBCXL,SBCIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ANAXH,ANAXL,ANAIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,XRAXH,XRAXL,XRAIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ORAXH,ORAXL,ORAIX,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,CMPXH,CMPXL,CMPIX,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,PREDDCB,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,14,0,23,0,15,0,0| -,POPX,-,XTIX,-,PUSHX,-,-
	.byte 0,8,0,0,0,0,0,0	| -,PCIX,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,10,0,0,0,0,0,0	|-,SPIX,-,-,-,-,-,-

| As above, for EDXX Z80 instructions.
cycletabl3:
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 12,12,15,20,8,14,8,9| INBC,OUTCB,DSBBB,SBCD,NEG,RETN,IM0,MOVIA
	.byte 12,12,15,20,0,14,0,9| INCC,OUTCC,DADCB,LBCD,-,RETI,-,MOVRA
	.byte 12,12,15,20,0,0,8,9| INDC,OUTCD,DSBBD,SDED,-,-,IM1,MOVAI
	.byte 12,12,15,20,0,0,8,9| INEC,OUTCE,DADCD,LDED,-,-,IM2,MOVAR
	.byte 12,12,15,0,0,0,0,19| INHC,OUTCH,DSBBH,-,-,-,-,RRD
	.byte 12,12,15,0,0,0,0,19| INLC,OUTCL,DADCH,-,-,-,-,RLD
	.byte 12,12,15,20,0,0,0,0| INMC,OUTCM,DSBBS,SSPD,-,-,-,-
	.byte 12,12,15,20,0,0,0,0| INAC,OUTCA,DADCS,LSPD,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 16,16,16,16,0,0,0,0| LDI,CPI,INI,OUTI,-,-,-,-
	.byte 16,16,16,16,0,0,0,0| LDD,CPD,IND,OUTD,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| LDIR,CPIR,INIR,OTIR,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| LDDR,CPDR,INDR,OTDR,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-

| As above, for FDXX Z80 instructions.
cycletabl4:
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,15,0,0,0,0,0,0	| -,DADYB,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,15,0,0,0,0,0,0	| -,DADYD,-,-,-,-,-,-
	.byte 0,14,20,10,9,9,9,0| -,LXIY,SIYD,INXY,INRYH,DCRYH,MVIYH,-
	.byte 0,15,20,10,9,9,9,0| -,DADYY,LIYD,DCXY,INRYL,DCRYL,MVIYL,-
	.byte 0,0,0,0,23,23,19,0| -,-,-,-,INRIY,DCRIY,MVIIY,-
	.byte 0,15,0,0,0,0,0,0	| -,DADYS,-,-,-,-,-,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVBYH,MOVBYL,MOVBIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVCYH,MOVCYL,MOVCIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVDYH,MOVDYL,MOVDIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVEYH,MOVEYL,MOVEIY,-
	.byte 9,9,9,9,9,9,19,9	| MOVYHB,MOVYHC,MOVYHD,MOVYHE,MOVYHYH,MOVYHYL,MOVYHIY,MOVYHA
	.byte 9,9,9,9,9,9,19,9	| MOVYLB,MOVYLC,MOVYLD,MOVYLE,MOVYLYH,MOVLHYL,MOLYHIY,MLVYHA
	.byte 19,19,19,19,19,19,0,19| MOVIYB,MOVIYC,MOVIYD,MOVIYE,MOVIYH,MOVIYL,-,MOVIYA
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,MOVAYH,MOVAYL,MOVAIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ADDYH,ADDYL,ADDIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ADCYH,ADCYL,ADCIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,SUBYH,SUBYL,SUBIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,SBCYH,SBCYL,SBCIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ANAYH,ANAYL,ANAIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,YRAYH,YRAYL,YRAIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,ORAYH,ORAYL,ORAIY,-
	.byte 0,0,0,0,9,9,19,0	| -,-,-,-,CMPYH,CMPYL,CMPIY,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,PREDDCB,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,14,0,23,0,15,0,0| -,POPY,-,XTIY,-,PUSHY,-,-
	.byte 0,8,0,0,0,0,0,0	| -,PCIY,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,10,0,0,0,0,0,0	| -,SPIY,-,-,-,-,-,-

| As above, for DDCBddXX Z80 instructions.
cycletabl5:
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RLC (IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RRC (IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RL (IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RR (IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SLA (IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SRA (IX+dd),-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SRL (IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 0,(IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 1,(IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 2,(IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 3,(IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 4,(IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 5,(IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 6,(IX+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 7,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 0,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 1,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 2,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 3,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 4,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 5,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 6,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 7,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 0,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 1,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 2,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 3,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 4,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 5,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 6,(IX+dd),-
	.byte 0,0,0,0,0,0,23,0	|-,-,-,-,-,-,SET 7,(IX+dd),-

| As above, for FDCBddXX Z80 instructions.
cycletabl6:
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RLC (IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RRC (IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RL (IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RR (IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SLA (IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SRA (IY+dd),-
	.byte 0,0,0,0,0,0,0,0	| -,-,-,-,-,-,-,-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SRL (IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 0,(IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 1,(IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 2,(IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 3,(IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 4,(IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 5,(IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 6,(IY+dd),-
	.byte 0,0,0,0,0,0,20,0	| -,-,-,-,-,-,BIT 7,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 0,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 1,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 2,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 3,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 4,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 5,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 6,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,RES 7,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 0,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 1,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 2,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 3,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 4,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 5,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 6,(IY+dd),-
	.byte 0,0,0,0,0,0,23,0	| -,-,-,-,-,-,SET 7,(IY+dd),-
#endif

#if defined(TRACE) && defined(CONTEST)
	.end oopcodesimulator
#else
	.end opcodesimulator
#endif
